{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///get-form-data.min.js","webpack:///webpack/bootstrap 22ddd748de6dbbbcf5f2","webpack:///C:/repos/get-form-data/src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","getFormData","form","options","arguments","length","undefined","trim","Error","data","elementName","elementNames","elementNameLookup","i","l","elements","element","IGNORED_ELEMENT_TYPES","type","disabled","name","push","value","getNamedFormElementData","toString","NODE_LIST_CLASSES","getFormElementValue","allRadios","concat","selectedIndex","selected","multiple","slice","files","CHECKED_INPUT_TYPES","checked","replace","TRIM_RE","__esModule","[object HTMLCollection]","[object NodeList]","[object RadioNodeList]","button","fieldset","reset","submit","checkbox","radio","Array","prototype","Object"],"mappings":"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","file":"get-form-data.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"getFormData\"] = factory();\n\telse\n\t\troot[\"getFormData\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"getFormData\"] = factory();\n\telse\n\t\troot[\"getFormData\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\tvar NODE_LIST_CLASSES = {\n\t  '[object HTMLCollection]': true,\n\t  '[object NodeList]': true,\n\t  '[object RadioNodeList]': true\n\t};\n\t\n\t// .type values for elements which can appear in .elements and should be ignored\n\tvar IGNORED_ELEMENT_TYPES = {\n\t  'button': true,\n\t  'fieldset': true,\n\t  // 'keygen': true,\n\t  // 'output': true,\n\t  'reset': true,\n\t  'submit': true\n\t};\n\t\n\tvar CHECKED_INPUT_TYPES = {\n\t  'checkbox': true,\n\t  'radio': true\n\t};\n\t\n\tvar TRIM_RE = /^\\s+|\\s+$/g;\n\t\n\tvar slice = Array.prototype.slice;\n\tvar toString = Object.prototype.toString;\n\t\n\t/**\n\t * @param {HTMLFormElement} form\n\t * @param {Object} options\n\t * @return {Object.<string,(string|Array.<string>)>} an object containing\n\t *   submittable value(s) held in the form's .elements collection, with\n\t *   properties named as per element names or ids.\n\t */\n\tfunction getFormData(form) {\n\t  var options = arguments.length <= 1 || arguments[1] === undefined ? { trim: false } : arguments[1];\n\t\n\t  if (!form) {\n\t    throw new Error('A form is required by getFormData, was given form=' + form);\n\t  }\n\t\n\t  var data = {};\n\t  var elementName = undefined;\n\t  var elementNames = [];\n\t  var elementNameLookup = {};\n\t\n\t  // Get unique submittable element names for the form\n\t  for (var i = 0, l = form.elements.length; i < l; i++) {\n\t    var element = form.elements[i];\n\t    if (IGNORED_ELEMENT_TYPES[element.type] || element.disabled) {\n\t      continue;\n\t    }\n\t    elementName = element.name || element.id;\n\t    if (elementName && !elementNameLookup[elementName]) {\n\t      elementNames.push(elementName);\n\t      elementNameLookup[elementName] = true;\n\t    }\n\t  }\n\t\n\t  // Extract element data name-by-name for consistent handling of special cases\n\t  // around elements which contain multiple inputs.\n\t  for (var i = 0, l = elementNames.length; i < l; i++) {\n\t    elementName = elementNames[i];\n\t    var value = getNamedFormElementData(form, elementName, options);\n\t    if (value != null) {\n\t      data[elementName] = value;\n\t    }\n\t  }\n\t\n\t  return data;\n\t}\n\t\n\t/**\n\t * @param {HTMLFormElement} form\n\t * @param {string} elementName\n\t * @param {Object} options\n\t * @return {(string|Array.<string>)} submittable value(s) in the form for a\n\t *   named element from its .elements collection, or null if there was no\n\t *   element with that name or the element had no submittable value(s).\n\t */\n\tfunction getNamedFormElementData(form, elementName) {\n\t  var options = arguments.length <= 2 || arguments[2] === undefined ? { trim: false } : arguments[2];\n\t\n\t  if (!form) {\n\t    throw new Error('A form is required by getNamedFormElementData, was given form=' + form);\n\t  }\n\t  if (!elementName && toString.call(elementName) !== '[object String]') {\n\t    throw new Error('A form element name is required by getNamedFormElementData, was given elementName=' + elementName);\n\t  }\n\t\n\t  var element = form.elements[elementName];\n\t  if (!element || element.disabled) {\n\t    return null;\n\t  }\n\t\n\t  if (!NODE_LIST_CLASSES[toString.call(element)]) {\n\t    return getFormElementValue(element, options.trim);\n\t  }\n\t\n\t  // Deal with multiple form controls which have the same name\n\t  var data = [];\n\t  var allRadios = true;\n\t  for (var i = 0, l = element.length; i < l; i++) {\n\t    if (element[i].disabled) {\n\t      continue;\n\t    }\n\t    if (allRadios && element[i].type !== 'radio') {\n\t      allRadios = false;\n\t    }\n\t    var value = getFormElementValue(element[i], options.trim);\n\t    if (value != null) {\n\t      data = data.concat(value);\n\t    }\n\t  }\n\t\n\t  // Special case for an element with multiple same-named inputs which were all\n\t  // radio buttons: if there was a selected value, only return the value.\n\t  if (allRadios && data.length === 1) {\n\t    return data[0];\n\t  }\n\t\n\t  return data.length > 0 ? data : null;\n\t}\n\t\n\t/**\n\t * @param {HTMLElement} element a form element.\n\t * @param {booleam} trim should values for text entry inputs be trimmed?\n\t * @return {(string|Array.<string>|File|Array.<File>)} the element's submittable\n\t *   value(s), or null if it had none.\n\t */\n\tfunction getFormElementValue(element, trim) {\n\t  var value = null;\n\t  var type = element.type;\n\t\n\t  if (type === 'select-one') {\n\t    if (element.options.length) {\n\t      value = element.options[element.selectedIndex].value;\n\t    }\n\t    return value;\n\t  }\n\t\n\t  if (type === 'select-multiple') {\n\t    value = [];\n\t    for (var i = 0, l = element.options.length; i < l; i++) {\n\t      if (element.options[i].selected) {\n\t        value.push(element.options[i].value);\n\t      }\n\t    }\n\t    if (value.length === 0) {\n\t      value = null;\n\t    }\n\t    return value;\n\t  }\n\t\n\t  // If a file input doesn't have a files attribute, fall through to using its\n\t  // value attribute.\n\t  if (type === 'file' && 'files' in element) {\n\t    if (element.multiple) {\n\t      value = slice.call(element.files);\n\t      if (value.length === 0) {\n\t        value = null;\n\t      }\n\t    } else {\n\t      // Should be null if not present, according to the spec\n\t      value = element.files[0];\n\t    }\n\t    return value;\n\t  }\n\t\n\t  if (!CHECKED_INPUT_TYPES[type]) {\n\t    value = trim ? element.value.replace(TRIM_RE, '') : element.value;\n\t  } else if (element.checked) {\n\t    value = element.value;\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tgetFormData.getNamedFormElementData = getNamedFormElementData;\n\t\n\texports['default'] = getFormData;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** get-form-data.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 22ddd748de6dbbbcf5f2\n **/","const NODE_LIST_CLASSES = {\n  '[object HTMLCollection]': true,\n  '[object NodeList]': true,\n  '[object RadioNodeList]': true\n}\n\n// .type values for elements which can appear in .elements and should be ignored\nconst IGNORED_ELEMENT_TYPES = {\n  'button': true,\n  'fieldset': true,\n  // 'keygen': true,\n  // 'output': true,\n  'reset': true,\n  'submit': true\n}\n\nconst CHECKED_INPUT_TYPES = {\n  'checkbox': true,\n  'radio': true\n}\n\nconst TRIM_RE = /^\\s+|\\s+$/g\n\nconst {slice} = Array.prototype\nconst {toString} = Object.prototype\n\n/**\n * @param {HTMLFormElement} form\n * @param {Object} options\n * @return {Object.<string,(string|Array.<string>)>} an object containing\n *   submittable value(s) held in the form's .elements collection, with\n *   properties named as per element names or ids.\n */\nfunction getFormData(form, options = {trim: false}) {\n  if (!form) {\n    throw new Error(`A form is required by getFormData, was given form=${form}`)\n  }\n\n  let data = {}\n  let elementName\n  let elementNames = []\n  let elementNameLookup = {}\n\n  // Get unique submittable element names for the form\n  for (let i = 0, l = form.elements.length; i < l; i++) {\n    let element = form.elements[i]\n    if (IGNORED_ELEMENT_TYPES[element.type] || element.disabled) {\n      continue\n    }\n    elementName = element.name || element.id\n    if (elementName && !elementNameLookup[elementName]) {\n      elementNames.push(elementName)\n      elementNameLookup[elementName] = true\n    }\n  }\n\n  // Extract element data name-by-name for consistent handling of special cases\n  // around elements which contain multiple inputs.\n  for (let i = 0, l = elementNames.length; i < l; i++) {\n    elementName = elementNames[i]\n    let value = getNamedFormElementData(form, elementName, options)\n    if (value != null) {\n      data[elementName] = value\n    }\n  }\n\n  return data\n}\n\n/**\n * @param {HTMLFormElement} form\n * @param {string} elementName\n * @param {Object} options\n * @return {(string|Array.<string>)} submittable value(s) in the form for a\n *   named element from its .elements collection, or null if there was no\n *   element with that name or the element had no submittable value(s).\n */\nfunction getNamedFormElementData(form, elementName, options = {trim: false}) {\n  if (!form) {\n    throw new Error(`A form is required by getNamedFormElementData, was given form=${form}`)\n  }\n  if (!elementName && toString.call(elementName) !== '[object String]') {\n    throw new Error(`A form element name is required by getNamedFormElementData, was given elementName=${elementName}`)\n  }\n\n  let element = form.elements[elementName]\n  if (!element || element.disabled) {\n    return null\n  }\n\n  if (!NODE_LIST_CLASSES[toString.call(element)]) {\n    return getFormElementValue(element, options.trim)\n  }\n\n  // Deal with multiple form controls which have the same name\n  let data = []\n  let allRadios = true\n  for (let i = 0, l = element.length; i < l; i++) {\n    if (element[i].disabled) {\n      continue\n    }\n    if (allRadios && element[i].type !== 'radio') {\n      allRadios = false\n    }\n    let value = getFormElementValue(element[i], options.trim)\n    if (value != null) {\n      data = data.concat(value)\n    }\n  }\n\n  // Special case for an element with multiple same-named inputs which were all\n  // radio buttons: if there was a selected value, only return the value.\n  if (allRadios && data.length === 1) {\n    return data[0]\n  }\n\n  return (data.length > 0 ? data : null)\n}\n\n/**\n * @param {HTMLElement} element a form element.\n * @param {booleam} trim should values for text entry inputs be trimmed?\n * @return {(string|Array.<string>|File|Array.<File>)} the element's submittable\n *   value(s), or null if it had none.\n */\nfunction getFormElementValue(element, trim) {\n  let value = null\n  let {type} = element\n\n  if (type === 'select-one') {\n    if (element.options.length) {\n      value = element.options[element.selectedIndex].value\n    }\n    return value\n  }\n\n  if (type === 'select-multiple') {\n    value = []\n    for (let i = 0, l = element.options.length; i < l; i++) {\n      if (element.options[i].selected) {\n        value.push(element.options[i].value)\n      }\n    }\n    if (value.length === 0) {\n      value = null\n    }\n    return value\n  }\n\n  // If a file input doesn't have a files attribute, fall through to using its\n  // value attribute.\n  if (type === 'file' && 'files' in element) {\n    if (element.multiple) {\n      value = slice.call(element.files)\n      if (value.length === 0) {\n        value = null\n      }\n    }\n    else {\n      // Should be null if not present, according to the spec\n      value = element.files[0]\n    }\n    return value\n  }\n\n  if (!CHECKED_INPUT_TYPES[type]) {\n    value = (trim ? element.value.replace(TRIM_RE, '') : element.value)\n  }\n  else if (element.checked) {\n    value = element.value\n  }\n\n  return value\n}\n\ngetFormData.getNamedFormElementData = getNamedFormElementData\n\nexport default getFormData\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/get-form-data/src/index.js\n **/"],"sourceRoot":""}